## Prefacio a la primera edición

>Una computadora es como un violín. Puedes imaginarte a un novato probando primero un fonógrafo y después el violín. Este último, dice, suena terrible. Este es el argumento que hemos escuchado de nuestros humanistas y de la mayoría de nuestros científicos de la computación. Los programas de computadora son buenos, dicen, para propósitos particulares, pero no son flexibles. Tampoco lo es un violín, o una máquina de escribir, hasta que uno aprende a usarlo.
>
> **Marvin Minsky**, *Why Programming Is a Good Medium for Expresing Poorly-Undertood and Sloppily-Formulated Ideas* `(NdT: en español, "Por qué la programación es un buen medio para expresar ideas mal entendidas y mal formuladas")`.

"Estructura e Interpretación de Programas Informáticos" es la asignatura de nivel básico en ciencias de la computación en el Instituto Tecnológico de Massachusetts. Se les requiere a todos los estudiantes del MIT que se especializan en ingeniería eléctrica o en ciencias de la computación, como una cuarta parte del "currículo central común", el que también incluye dos asignaturas sobre circuitos y sistemas lineales y una asignatura sobre el diseño de sistemas digitales. Hemos estado involucrados en el desarrollo de esta materia desde 1978, y hemos enseñado este material en su forma actual desde el otoño de 1980 a alrededor de 600 a 700 estudiantes cada año. La mayoría de estos estudiantes han tenido poca o ninguna formación formal previa en computación, aunque varios han jugado un poco con computadoras y otros cuantos han tenido una amplia experiencia en programación o diseño de hardware.

Nuestro diseño de este tema introductorio de ciencias de la computación refleja dos preocupaciones principales. En primer lugar, queremos establecer la idea de que un lenguaje informático no es sólo una forma de conseguir que una computadora realice operaciones, sino que además es un medio formal novedoso para expresar ideas acerca de metodología. Por lo tanto, los programas deben ser escritos para que la gente los lea, y sólo incidentalmente para que las máquinas los ejecuten. En segundo lugar, creemos que el material esencial que debe ser abordado por un tema de este nivel no es la sintaxis de construcciones particulares de un lenguaje de programación, ni algoritmos ingeniosos para calcular funciones particulares de manera eficiente, ni siquiera el análisis matemático de los algoritmos y los fundamentos de la computación, sino más bien las técnicas utilizadas para controlar la complejidad intelectual de grandes sistemas de software.

Nuestro objetivo es que los estudiantes que completen esta asignatura obtengan un buen entendimiento de los elementos de estilo y de la estética de la programación. Deberán dominar las principales técnicas para controlar la complejidad en un sistema grande. Deberán ser capaces de leer un programa de 50 páginas de largo, si es que está escrito de un modo ejemplar. Deberán saber qué cosas no leer, y qué cosas no necesitan entender en todo momento. Deben sentirse seguros de modificar un programa, conservando el espíritu y el estilo del autor original.

Estas habilidades no son de ninguna manera exclusivas de la programación de computadoras. Las técnicas que enseñamos y en las que nos basamos son comunes a todo diseño de ingeniería. Nosotros controlamos la complejidad construyendo abstracciones que ocultan detalles cuando es apropiado. Controlamos la complejidad mediante el establecimiento de interfaces convencionales que nos permiten construir sistemas mediante la combinación de piezas estándar y bien entendidas a modo de "mezclar y encajar". Controlamos la complejidad mediante el establecimiento de nuevos lenguajes para describir un diseño, cada uno de los cuales hace énfasis en aspectos particulares del diseño y minimiza el énfasis en otros.

Detrás de nuestro enfoque de este tema está nuestra convicción de que las "ciencias de la computación" no son una ciencia y que su importancia tiene poco que ver con las computadoras. La revolución de las máquinas es una revolución en la forma en que pensamos y en la forma en que expresamos lo que pensamos. La esencia de este cambio es el surgimiento de lo que podría llamarse *epistemología procedural*: el estudio de la estructura del conocimiento desde un punto de vista imperativo, en oposición al punto de vista más declarativo adoptado por las asignaturas matemáticas clásicas. Las matemáticas proporcionan un marco para tratar con precisión nociones de "lo que es". La computación proporciona un marco para tratar con precisión las nociones de "cómo hacer".

Al enseñar nuestro material utilizamos un dialecto del lenguaje de programación Lisp. Nunca enseñamos formalmente el lenguaje porque no es necesario. Sólo lo usamos, y los estudiantes lo aprenden en unos pocos días. Esta es una gran ventaja de los lenguajes del tipo Lisp: tienen muy pocas maneras de formar expresiones compuestas, y casi ninguna estructura sintáctica. Todas las propiedades formales pueden ser cubiertas en una hora, como las reglas del ajedrez. Después de un corto tiempo nos olvidamos de los detalles sintácticos del lenguaje (porque no hay ninguno) y seguimos con los problemas reales: averiguando qué es lo que queremos calcular, cómo vamos a descomponer los problemas en partes manejables y cómo vamos a trabajar con las partes. Otra ventaja de Lisp es que soporta (pero no obliga) una gran cantidad de estrategias a gran escala para la descomposición modular de programas, más que cualquier otro lenguaje que conocemos. Podemos hacer abstracciones de procedimientos y de datos, podemos usar funciones de orden superior para capturar patrones comunes de uso, podemos modelar el estado local usando asignación y mutación de datos, podemos vincular partes de un programa con secuencias y evaluación diferida, y podemos implementar fácilmente lenguajes integrados `(NdT: en inglés "embedded languages")`. Todo esto está integrado en un entorno interactivo con un excelente soporte para el diseño, construcción, pruebas y depuración de programas incrementales. Agradecemos a todas las generaciones de magos de Lisp, empezando por John McCarthy, que han creado una magnífica herramienta de una potencia y elegancia sin precedentes.

Scheme, el dialecto de Lisp que usamos, es un intento de unir el poder y la elegancia de Lisp y Algol. De Lisp tomamos el poder metalingüístico que se deriva de la sintaxis simple, la representación uniforme de los programas como objetos de datos, y los datos asignados al heap con recolección de basura `(NdT: en español "heap" podría traducirse como *montículo*, que es un área de memoria dinámica; y "recolección de basura" viene de "garbage collection")`. De Algol tomamos el alcance léxico y la estructura de bloques, que son aportes de los pioneros del diseño de lenguajes de programación que formaron parte del comité de Algol. Deseamos citar a John Reynolds y Peter Landin por su visión de la relación entre el cálculo lambda de Church a la estructura de los lenguajes de programación. También reconocemos nuestra deuda con los matemáticos que exploraron este territorio décadas antes de que las computadoras aparezcan en escena. Estos pioneros incluyen a Alonzo Church, Barkley Rosser, Stephen Kleene y Haskell Curry.